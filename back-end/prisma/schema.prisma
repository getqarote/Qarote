// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  USER
  READONLY
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
}

enum WorkspacePlan {
  FREE
  DEVELOPER
  ENTERPRISE
}

enum AlertType {
  QUEUE_DEPTH
  MESSAGE_RATE
  CONSUMER_COUNT
  MEMORY_USAGE
  DISK_USAGE
  CONNECTION_COUNT
  CHANNEL_COUNT
  NODE_DOWN
  EXCHANGE_ERROR
}

enum AlertSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum AlertStatus {
  ACTIVE
  ACKNOWLEDGED
  RESOLVED
}

enum ComparisonOperator {
  GREATER_THAN
  LESS_THAN
  EQUALS
  NOT_EQUALS
}

enum FeedbackType {
  BUG
  FEATURE
  GENERAL
  IMPROVEMENT
}

enum FeedbackCategory {
  UI_UX
  PERFORMANCE
  SECURITY
  FUNCTIONALITY
  DOCUMENTATION
  OTHER
}

enum FeedbackPriority {
  LOW
  MEDIUM
  HIGH
}

enum FeedbackStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  INCOMPLETE
  INCOMPLETE_EXPIRED
  TRIALING
  UNPAID
}

enum PaymentStatus {
  SUCCEEDED
  PENDING
  FAILED
  CANCELED
  REQUIRES_ACTION
}

enum BillingInterval {
  MONTH
  YEAR
}

model Workspace {
  id           String         @id @default(uuid())
  name         String
  contactEmail String?
  logoUrl      String?
  plan         WorkspacePlan  @default(FREE)
  

  
  // Stripe integration
  stripeCustomerId      String?   @unique
  stripeSubscriptionId  String?   @unique
  
  users                    User[]
  servers                  RabbitMQServer[]
  alertRules               AlertRule[]
  alerts                   Alert[]
  feedback                 Feedback[]
  monthlyMessageCounts     MonthlyMessageCount[]
  capturedMessages         CapturedMessage[]
  retentionPolicy          UserRetentionPolicy?
  
  // Payment relations
  subscription             Subscription?
  payments                 Payment[]
  
  // Alert preferences
  alertThresholds          WorkspaceAlertThresholds?
  
  createdAt                DateTime       @default(now())
  updatedAt                DateTime       @updatedAt
  invitations              Invitation[]
}

model User {
  id             String    @id @default(uuid())
  email          String    @unique
  passwordHash   String
  firstName       String
  lastName       String
  role           UserRole  @default(USER)
  isActive       Boolean   @default(true)
  
  // Email verification
  emailVerified  Boolean   @default(false)
  emailVerifiedAt DateTime?
  pendingEmail   String?   // For email change requests
  
  lastLogin      DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  workspaceId    String
  workspace      Workspace  @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  invitations    Invitation[] @relation("InvitedUser")
  invitedBy      Invitation[] @relation("InvitingUser")
  alerts         Alert[]
  alertRules     AlertRule[]
  
  // Feedback relations
  feedback       Feedback[]
  feedbackResponses Feedback[] @relation("FeedbackResponses")
  
  // Email verification tokens
  emailVerificationTokens EmailVerificationToken[]

  // Password reset tokens
  passwordResets PasswordReset[]
}

model PasswordReset {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
}

model Invitation {
  id             String           @id @default(uuid())
  email          String
  token          String           @unique
  workspaceId    String
  workspace      Workspace        @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  invitedById    String
  invitedBy      User             @relation("InvitingUser", fields: [invitedById], references: [id], onDelete: Cascade)
  invitedUserId  String?
  invitedUser    User?            @relation("InvitedUser", fields: [invitedUserId], references: [id], onDelete: SetNull)
  role           UserRole         @default(USER)
  status         InvitationStatus @default(PENDING)
  expiresAt      DateTime
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
}

model EmailVerificationToken {
  id             String   @id @default(uuid())
  token          String   @unique
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  email          String   // The email address to verify (current or pending)
  type           String   // "SIGNUP" or "EMAIL_CHANGE"
  expiresAt      DateTime
  createdAt      DateTime @default(now())
  
  @@index([userId])
  @@index([token])
}

model RabbitMQServer {
  id                  String      @id @default(uuid())
  name                String
  host                String
  port                Int         // Management API port (default: 15672)
  amqpPort            Int         @default(5672) // AMQP protocol port (default: 5672)
  username            String
  password            String
  vhost               String      @default("/")
  useHttps            Boolean     @default(false) // Protocol selection separate from SSL config
  sslEnabled          Boolean     @default(false)
  sslVerifyPeer       Boolean     @default(true)
  sslCaCertContent    String?     @db.Text
  sslClientCertContent String?    @db.Text
  sslClientKeyContent String?     @db.Text
  version             String?     // RabbitMQ version (e.g., "3.12.10", "4.0.1")
  versionMajorMinor   String?     // Major.Minor version for plan validation (e.g., "3.12", "4.0")
  
  // Plan validation fields
  isOverQueueLimit    Boolean     @default(false) // True if server has more queues than plan allows
  queueCountAtConnect Int?        // Number of queues when server was connected
  overLimitWarningShown Boolean   @default(false) // True if warning has been shown to user
  
  // Queue pause states (JSON field to store pause state per queue)
  queuePauseStates    Json?       // Stores map of queueName -> QueuePauseState
  
  workspaceId             String?
  workspace               Workspace?           @relation(fields: [workspaceId], references: [id], onDelete: SetNull)
  createdAt               DateTime             @default(now())
  updatedAt               DateTime             @updatedAt
  Queues                  Queue[]
  alertRules              AlertRule[]
  capturedMessages        CapturedMessage[]
}

model Queue {
  id             String        @id @default(uuid())
  name           String
  vhost          String
  serverId       String
  server         RabbitMQServer @relation(fields: [serverId], references: [id], onDelete: Cascade)
  messages       Int
  messagesReady  Int
  messagesUnack  Int
  lastFetched    DateTime
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  QueueMetrics   QueueMetric[]

  @@unique([name, vhost, serverId])
}

model QueueMetric {
  id            String   @id @default(uuid())
  queueId       String
  queue         Queue    @relation(fields: [queueId], references: [id], onDelete: Cascade)
  timestamp     DateTime @default(now())
  messages      Int
  messagesReady Int
  messagesUnack Int
  publishRate   Float
  consumeRate   Float

  @@index([queueId, timestamp])
}

model Alert {
  id            String        @id @default(uuid())
  title         String
  description   String
  severity      AlertSeverity
  status        AlertStatus   @default(ACTIVE)
  value         Float?        // The actual value that triggered the alert
  threshold     Float?        // The threshold that was breached
  
  // Relations
  alertRuleId   String?
  alertRule     AlertRule?    @relation(fields: [alertRuleId], references: [id], onDelete: SetNull)
  workspaceId   String
  workspace     Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  createdById   String?
  createdBy     User?         @relation(fields: [createdById], references: [id], onDelete: SetNull)
  
  // Timestamps
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  resolvedAt    DateTime?
  acknowledgedAt DateTime?
}

model AlertRule {
  id          String             @id @default(cuid())
  name        String
  description String?
  type        AlertType
  threshold   Float
  operator    ComparisonOperator
  severity    AlertSeverity
  enabled     Boolean            @default(true)
  
  // Relations
  serverId    String
  server      RabbitMQServer     @relation(fields: [serverId], references: [id], onDelete: Cascade)
  workspaceId String
  workspace   Workspace          @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  createdById String
  createdBy   User               @relation(fields: [createdById], references: [id], onDelete: Cascade)
  
  // Metadata
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  
  // Generated alerts
  alerts      Alert[]
}

model WorkspaceAlertThresholds {
  id          String    @id @default(uuid())
  
  // Node health thresholds
  memoryWarning           Float     @default(80.0)   // Memory usage percentage
  memoryCritical          Float     @default(90.0)
  diskWarning             Float     @default(80.0)   // Disk usage percentage
  diskCritical            Float     @default(90.0)
  fileDescriptorsWarning  Float     @default(80.0)   // File descriptors usage percentage
  fileDescriptorsCritical Float     @default(90.0)
  socketsWarning          Float     @default(80.0)   // Socket usage percentage
  socketsCritical         Float     @default(90.0)
  processesWarning        Float     @default(80.0)   // Process count percentage
  processesCritical       Float     @default(90.0)
  
  // Queue health thresholds
  unackedMessagesWarning      Int   @default(1000)   // Unacknowledged messages count
  unackedMessagesCritical     Int   @default(5000)
  consumerUtilizationWarning  Float @default(20.0)   // Consumer utilization percentage (low is bad)
  consumerUtilizationCritical Float @default(10.0)
  runQueueWarning             Int   @default(50)     // Erlang run queue length
  runQueueCritical            Int   @default(100)
  
  // Relations
  workspaceId String    @unique
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  
  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model Feedback {
  id          String           @id @default(uuid())
  type        FeedbackType
  category    FeedbackCategory
  title       String           @db.VarChar(100)
  description String           @db.Text
  priority    FeedbackPriority @default(MEDIUM)
  status      FeedbackStatus   @default(OPEN)
  email       String?          @db.VarChar(255)
  
  // Metadata (stored as JSON for flexibility)
  metadata    Json?
  
  // Relations
  userId      String?
  user        User?            @relation(fields: [userId], references: [id], onDelete: SetNull)
  workspaceId String?
  workspace   Workspace?       @relation(fields: [workspaceId], references: [id], onDelete: SetNull)
  
  // Response tracking
  response       String?       @db.Text
  respondedById  String?
  respondedBy    User?         @relation("FeedbackResponses", fields: [respondedById], references: [id], onDelete: SetNull)
  respondedAt    DateTime?
  
  // Timestamps
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  
  @@index([status], name: "feedback_status_idx")
  @@index([type], name: "feedback_type_idx")
  @@index([priority], name: "feedback_priority_idx")
  @@index([workspaceId], name: "feedback_workspace_idx")
  @@index([createdAt], name: "feedback_created_at_idx")
}

model TempCache {
  key       String   @id @db.VarChar(255)
  value     Json
  expiresAt DateTime @map("expires_at") @db.Timestamptz(3)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(3)

  @@index([expiresAt], name: "temp_cache_expires_at_idx")
  @@index([createdAt], name: "temp_cache_created_at_idx")
  @@map("temp_cache")
}

model MonthlyMessageCount {
  id          String   @id @default(uuid())
  workspaceId String
  year        Int
  month       Int      // 1-12
  count       Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  // Ensure unique monthly count per workspace
  @@unique([workspaceId, year, month], name: "monthly_message_count_unique")
  @@index([workspaceId], name: "monthly_message_count_workspace_idx")
  @@index([year, month], name: "monthly_message_count_date_idx")
  @@map("monthly_message_counts")
}

model CapturedMessage {
  id                  BigInt    @id @default(autoincrement())
  workspaceId         String
  serverId            String
  queueName           String
  vhost               String    @default("/")
  
  // Message content
  payload             String
  payloadEncoding     String    @default("string") // 'string', 'base64', 'json'
  payloadSize         Int
  
  // Message properties (stored as JSON for flexibility)
  properties          Json?
  headers             Json?
  routingKey          String?
  exchangeName        String?
  deliveryMode        Int?
  priority            Int?
  correlationId       String?
  replyTo             String?
  messageId           String?
  appId               String?
  contentType         String?
  contentEncoding     String?
  expiration          String?
  
  // Message state
  redelivered         Boolean   @default(false)
  deliveryTag         BigInt?
  consumerTag         String?
  
  // Timestamps
  messageTimestamp    DateTime? // From message properties
  publishedAt         DateTime  @default(now())
  consumedAt          DateTime? // Set when message is actually consumed/acked
  capturedAt          DateTime  @default(now())
  
  // Partitioning key
  partitionDate       DateTime  @default(now()) @db.Date
  
  // Relations
  workspace           Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  server              RabbitMQServer @relation(fields: [serverId], references: [id], onDelete: Cascade)
  
  // Indexes for high-performance querying
  @@index([workspaceId, serverId, queueName, consumedAt(sort: Desc)], name: "captured_messages_workspace_server_queue_idx")
  @@index([workspaceId, consumedAt(sort: Desc)], name: "captured_messages_workspace_time_idx")
  @@index([exchangeName, routingKey], name: "captured_messages_exchange_routing_idx")
  @@index([correlationId], name: "captured_messages_correlation_idx")
  @@index([messageId], name: "captured_messages_message_id_idx")
  @@index([partitionDate], name: "captured_messages_partition_idx")
  @@map("captured_messages")
}

model UserRetentionPolicy {
  id                    String    @id @default(uuid())
  workspaceId           String    @unique
  retentionDays         Int       @default(1)
  maxMessageSizeMb      Int       @default(10)
  maxStorageGb          Int       @default(1)
  autoCleanup           Boolean   @default(true)
  compressOldMessages   Boolean   @default(false)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  
  // Relations
  workspace             Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  
  @@index([workspaceId], name: "user_retention_workspace_idx")
  @@index([autoCleanup, updatedAt], name: "user_retention_cleanup_idx")
  @@map("user_retention_policies")
}

model Subscription {
  id                    String             @id @default(uuid())
  workspaceId           String             @unique
  stripeSubscriptionId  String             @unique
  stripePriceId         String
  stripeCustomerId      String
  
  // Subscription details
  plan                  WorkspacePlan
  status                SubscriptionStatus
  billingInterval       BillingInterval
  
  // Pricing
  pricePerMonth         Decimal            @db.Decimal(10,2)
  currency              String             @default("usd")
  
  // Billing periods
  currentPeriodStart    DateTime
  currentPeriodEnd      DateTime
  
  // Trial information
  trialStart            DateTime?
  trialEnd              DateTime?
  
  // Cancellation
  cancelAtPeriodEnd     Boolean            @default(false)
  canceledAt            DateTime?
  cancelationReason     String?
  
  // Renewal tracking
  isRenewalAfterCancel  Boolean            @default(false)
  previousCancelDate    DateTime?
  
  // Metadata
  metadata              Json?
  
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt
  
  // Relations
  workspace             Workspace          @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  
  @@index([stripeSubscriptionId], name: "subscription_stripe_id_idx")
  @@index([workspaceId], name: "subscription_workspace_idx")
  @@index([status], name: "subscription_status_idx")
  @@map("subscriptions")
}

model Payment {
  id                  String        @id @default(uuid())
  workspaceId         String
  stripePaymentId     String        @unique
  stripeInvoiceId     String?
  stripeChargeId      String?
  
  // Payment details
  amount              Decimal       @db.Decimal(10,2)
  currency            String        @default("usd")
  status              PaymentStatus
  
  // Description and metadata
  description         String?
  plan                WorkspacePlan?
  billingInterval     BillingInterval?
  
  // Billing period covered by this payment
  periodStart         DateTime?
  periodEnd           DateTime?
  
  // Payment processing
  paymentMethodId     String?
  paymentMethodType   String?       // card, bank_transfer, etc.
  
  // Failure information
  failureCode         String?
  failureMessage      String?
  
  // Receipt and invoice
  receiptUrl          String?
  invoiceUrl          String?
  
  // Metadata from Stripe
  metadata            Json?
  
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt
  paidAt              DateTime?
  
  // Relations
  workspace           Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  
  @@index([workspaceId], name: "payment_workspace_idx")
  @@index([status], name: "payment_status_idx")
  @@index([stripePaymentId], name: "payment_stripe_id_idx")
  @@index([createdAt], name: "payment_created_at_idx")
  @@map("payments")
}

model StripeWebhookEvent {
  id              String    @id @default(uuid())
  stripeEventId   String    @unique
  eventType       String
  processed       Boolean   @default(false)
  
  // Event data
  data            Json
  
  // Processing information
  processedAt     DateTime?
  errorMessage    String?
  retryCount      Int       @default(0)
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([stripeEventId], name: "webhook_stripe_event_idx")
  @@index([eventType], name: "webhook_event_type_idx")
  @@index([processed], name: "webhook_processed_idx")
  @@map("stripe_webhook_events")
}